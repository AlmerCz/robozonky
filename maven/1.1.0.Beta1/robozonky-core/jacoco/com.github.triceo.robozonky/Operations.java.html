<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Operations.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">robozonky-core</a> &gt; <a href="index.source.html" class="el_package">com.github.triceo.robozonky</a> &gt; <span class="el_source">Operations.java</span></div><h1>Operations.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 Lukáš Petrovický
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.github.triceo.robozonky;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.stream.Collectors;

import com.github.triceo.robozonky.authentication.Authentication;
import com.github.triceo.robozonky.authentication.Authenticator;
import com.github.triceo.robozonky.exceptions.LoginFailedException;
import com.github.triceo.robozonky.exceptions.LogoutFailedException;
import com.github.triceo.robozonky.remote.Investment;
import com.github.triceo.robozonky.remote.InvestmentStatus;
import com.github.triceo.robozonky.remote.InvestmentStatuses;
import com.github.triceo.robozonky.remote.Loan;
import com.github.triceo.robozonky.remote.Rating;
import com.github.triceo.robozonky.remote.Ratings;
import com.github.triceo.robozonky.remote.RiskPortfolio;
import com.github.triceo.robozonky.remote.Statistics;
import com.github.triceo.robozonky.remote.ZonkyApi;
import com.github.triceo.robozonky.strategy.InvestmentStrategy;
import org.apache.commons.collections4.MultiValuedMap;
import org.apache.commons.collections4.multimap.HashSetValuedHashMap;
import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
import org.jboss.resteasy.plugins.providers.RegisterBuiltin;
import org.jboss.resteasy.plugins.providers.jackson.ResteasyJackson2Provider;
import org.jboss.resteasy.spi.ResteasyProviderFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

<span class="nc" id="L55">public class Operations {</span>

    public static final int MINIMAL_INVESTMENT_ALLOWED = 200;
    protected static final String ZONKY_VERSION_UNDETECTED = &quot;UNDETECTED&quot;;
    protected static final String ZONKY_VERSION_UNKNOWN = &quot;UNKNOWN&quot;;

    private static final int CONNECTION_POOL_SIZE = 2;
    private static final String ZONKY_URL = &quot;https://api.zonky.cz&quot;;

<span class="fc" id="L64">    private static final Logger LOGGER = LoggerFactory.getLogger(Operations.class);</span>

    /**
     * Get the share of 'payments due for each rating' on the overall portfolio.
     * @param stats
     * @param investments Loans which have already been invested in by the current user.
     * @return Map where each rating is the key and value is the share of that rating among overall due payments.
     */
    static Map&lt;Rating, BigDecimal&gt; calculateSharesPerRating(final Statistics stats,
                                                            final Collection&lt;Investment&gt; investments) {
<span class="fc" id="L74">        final Map&lt;Rating, BigDecimal&gt; amounts = stats.getRiskPortfolio().stream().collect(</span>
<span class="fc" id="L75">                Collectors.toMap(RiskPortfolio::getRating, risk -&gt; BigDecimal.valueOf(risk.getUnpaid()))</span>
        );
        // make sure ratings are present even when there's 0 invested in them
<span class="fc bfc" id="L78" title="All 2 branches covered.">        Arrays.stream(Rating.values()).filter(r -&gt; !amounts.containsKey(r))</span>
<span class="fc" id="L79">                .forEach(r -&gt; amounts.put(r, BigDecimal.ZERO));</span>
        // make sure the share reflects investments made by ZonkyBot which have not yet been reflected in the API
<span class="fc" id="L81">        investments.forEach(previousInvestment -&gt; {</span>
<span class="fc" id="L82">            final Rating r = previousInvestment.getRating();</span>
<span class="fc" id="L83">            final BigDecimal investment = BigDecimal.valueOf(previousInvestment.getAmount());</span>
<span class="fc" id="L84">            amounts.put(r, amounts.get(r).add(investment));</span>
<span class="fc" id="L85">        });</span>
<span class="fc" id="L86">        final BigDecimal total = Util.sum(amounts.values());</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (total.compareTo(BigDecimal.ZERO) == 0) { // no ratings have any investments</span>
<span class="fc" id="L88">            return Collections.unmodifiableMap(amounts);</span>
        }
<span class="fc" id="L90">        final Map&lt;Rating, BigDecimal&gt; result = new EnumMap&lt;&gt;(Rating.class);</span>
<span class="fc" id="L91">        amounts.forEach((rating, amount) -&gt; result.put(rating, amount.divide(total, 4, RoundingMode.HALF_EVEN)));</span>
<span class="fc" id="L92">        return Collections.unmodifiableMap(result);</span>
    }

    /**
     * Put money into an already selected loan.
     * @param oc Context for the current session.
     * @param l Loan to invest into.
     * @param investmentsInSession Previous loans invested in this session.
     * @param balance Latest known Zonky account balance.
     * @return Present only if Zonky API confirmed money was invested or if dry run.
     */
    static Optional&lt;Investment&gt; actuallyInvest(final OperationsContext oc, final Loan l,
                                               final List&lt;Investment&gt; investmentsInSession, final BigDecimal balance) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (Util.isLoanPresent(l, investmentsInSession)) {</span>
<span class="fc" id="L106">            Operations.LOGGER.info(&quot;RoboZonky already invested in loan '{}', skipping. May only happen in dry runs.&quot;, l);</span>
<span class="fc" id="L107">            return Optional.empty();</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        } else if (!oc.getStrategy().isAcceptable(l)) {</span>
<span class="fc" id="L109">            Operations.LOGGER.info(&quot;According to the investment strategy, loan '{}' is not acceptable.&quot;, l);</span>
<span class="fc" id="L110">            return Optional.empty();</span>
        }
        // figure out how much to invest
<span class="fc" id="L113">        final int resultingInvestment = oc.getStrategy().recommendInvestmentAmount(l, balance);</span>
<span class="fc" id="L114">        Operations.LOGGER.debug(&quot;Strategy recommended to invest {} CZK on balance of {} CZK.&quot;, resultingInvestment,</span>
<span class="fc" id="L115">                balance.intValue());</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (resultingInvestment &lt; Operations.MINIMAL_INVESTMENT_ALLOWED) {</span>
<span class="fc" id="L117">            Operations.LOGGER.info(&quot;Not investing into loan '{}', since investment ({} CZK) less than bare minimum.&quot;,</span>
<span class="fc" id="L118">                    l, resultingInvestment);</span>
<span class="fc" id="L119">            return Optional.empty();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        } else if (resultingInvestment &gt; balance.intValue()) {</span>
<span class="fc" id="L121">            Operations.LOGGER.info(&quot;Not investing into loan '{}', since investment ({} CZK) more than {} CZK balance.&quot;,</span>
<span class="fc" id="L122">                    l, resultingInvestment, balance);</span>
<span class="fc" id="L123">            return Optional.empty();</span>
        }
<span class="fc" id="L125">        return Operations.invest(oc, l, resultingInvestment);</span>
    }

    /**
     * Choose from available loans of a given rating one loan to invest money into.
     * @param oc Context for the current session.
     * @param r Rating in question.
     * @param loansFuture Loans carrying that rating.
     * @param investmentsInSession Previous investments made in this session.
     * @param balance Latest known Zonky account balance.
     * @return Present only if Zonky API confirmed money was invested or if dry run.
     */
    static Optional&lt;Investment&gt; identifyLoanToInvest(final OperationsContext oc, final Rating r,
                                                     final Future&lt;Collection&lt;Loan&gt;&gt; loansFuture,
                                                     final List&lt;Investment&gt; investmentsInSession,
                                                     final BigDecimal balance) {
        final Collection&lt;Loan&gt; loans;
        try {
<span class="fc" id="L143">            loans = loansFuture.get();</span>
<span class="fc" id="L144">        } catch (final Exception e) {</span>
<span class="fc" id="L145">            Operations.LOGGER.warn(&quot;Could not list loans with rating '{}'. Can not invest in that rating.&quot;, r, e);</span>
<span class="fc" id="L146">            return Optional.empty();</span>
<span class="fc" id="L147">        }</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (loans.size() == 0) {</span>
<span class="fc" id="L149">            Operations.LOGGER.info(&quot;There are no loans of rating '{}' matching the investment strategy.&quot;, r);</span>
<span class="fc" id="L150">            return Optional.empty();</span>
        }
        // sort loans by their term and start investing
<span class="fc" id="L153">        final boolean prefersLongTerm = oc.getStrategy().prefersLongerTerms(r);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        Operations.LOGGER.info(&quot;Investment strategy for rating '{}' prefers {} term loans.&quot;, r,</span>
                prefersLongTerm ? &quot;longer&quot; : &quot;shorter&quot;);
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (final Loan l : Util.sortLoansByTerm(loans, prefersLongTerm)) {</span>
<span class="fc" id="L157">            final Optional&lt;Investment&gt; investment = Operations.actuallyInvest(oc, l, investmentsInSession, balance);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">            if (investment.isPresent()) {</span>
<span class="fc" id="L159">                return investment;</span>
            }
<span class="fc" id="L161">        }</span>
<span class="fc" id="L162">        return Optional.empty();</span>
    }

    /**
     *
     * @param oc Context for the current session.
     * @param currentShare Current share of investments in a given rating.
     * @return Ratings in the order of decreasing demand. Over-invested ratings not present.
     */
    static List&lt;Rating&gt; rankRatingsByDemand(final OperationsContext oc, final Map&lt;Rating, BigDecimal&gt; currentShare) {
<span class="fc" id="L172">        final MultiValuedMap&lt;BigDecimal, Rating&gt; mostWantedRatings = new HashSetValuedHashMap&lt;&gt;();</span>
        // put the ratings into buckets based on how much we're missing them
<span class="fc" id="L174">        currentShare.forEach((r, currentRatingShare) -&gt; {</span>
<span class="fc" id="L175">            final BigDecimal maximumAllowedShare = oc.getStrategy().getTargetShare(r);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            if (currentRatingShare.compareTo(maximumAllowedShare) &gt;= 0) { // we bought too many of this rating; ignore</span>
<span class="fc" id="L177">                return;</span>
            }
<span class="fc" id="L179">            mostWantedRatings.put(maximumAllowedShare.subtract(currentRatingShare), r);</span>
<span class="fc" id="L180">        });</span>
        // and now output ratings in an order, bigger first
<span class="fc" id="L182">        final List&lt;Rating&gt; result = new ArrayList&lt;&gt;(currentShare.size());</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        while (!mostWantedRatings.isEmpty()) {</span>
<span class="fc" id="L184">            BigDecimal biggestRanking = BigDecimal.ZERO;</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">            for (final BigDecimal tested: mostWantedRatings.keySet()) {</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                if (tested.compareTo(biggestRanking) &gt; 0) {</span>
<span class="fc" id="L187">                    biggestRanking = tested;</span>
                }
<span class="fc" id="L189">            }</span>
<span class="fc" id="L190">            result.addAll(mostWantedRatings.remove(biggestRanking));</span>
<span class="fc" id="L191">        }</span>
<span class="fc" id="L192">        return Collections.unmodifiableList(result);</span>
    }

    /**
     * Choose from available loans the most important loan to invest money into.
     * @param oc Context for the current session.
     * @param investmentsInSession Previous investments made in this session.
     * @param balance Latest known Zonky account balance.
     * @return Present only if Zonky API confirmed money was invested or if dry run.
     */
    static Optional&lt;Investment&gt; identifyLoanToInvest(final OperationsContext oc,
                                                     final List&lt;Investment&gt; investmentsInSession,
                                                     final BigDecimal balance) {
<span class="fc" id="L205">        final ZonkyApi api = oc.getAuthentication().getApi();</span>
<span class="fc" id="L206">        final Collection&lt;Investment&gt; investments = Util.mergeInvestments(</span>
<span class="fc" id="L207">                api.getInvestments(InvestmentStatuses.of(InvestmentStatus.SIGNED)), investmentsInSession);</span>
<span class="fc" id="L208">        final Map&lt;Rating, BigDecimal&gt; shareOfRatings = Operations.calculateSharesPerRating(api.getStatistics(),</span>
                investments);
<span class="fc" id="L210">        final List&lt;Rating&gt; mostWantedRatings = Operations.rankRatingsByDemand(oc, shareOfRatings);</span>
<span class="fc" id="L211">        Operations.LOGGER.debug(&quot;Current share of unpaid loans with a given rating is currently: {}.&quot;, shareOfRatings);</span>
<span class="fc" id="L212">        Operations.LOGGER.info(&quot;According to the investment strategy, the portfolio is low on following ratings: {}.&quot;,</span>
                mostWantedRatings);
<span class="fc" id="L214">        final Map&lt;Rating, Future&lt;Collection&lt;Loan&gt;&gt;&gt; availableLoans = new EnumMap&lt;&gt;(Rating.class);</span>
<span class="fc" id="L215">        mostWantedRatings.forEach(r -&gt; { // submit HTTP requests ahead of time</span>
<span class="fc" id="L216">            final Callable&lt;Collection&lt;Loan&gt;&gt; future</span>
<span class="fc" id="L217">                    = () -&gt; api.getLoans(Ratings.of(r), Operations.MINIMAL_INVESTMENT_ALLOWED);</span>
<span class="fc" id="L218">            availableLoans.put(r, oc.getBackgroundExecutor().submit(future));</span>
<span class="fc" id="L219">        });</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (final Rating r : mostWantedRatings) { // try to invest in a given rating</span>
<span class="fc" id="L221">            final Optional&lt;Investment&gt; investment =</span>
<span class="fc" id="L222">                    Operations.identifyLoanToInvest(oc, r, availableLoans.get(r), investmentsInSession, balance);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (investment.isPresent()) {</span>
<span class="fc" id="L224">                return investment;</span>
            }
<span class="fc" id="L226">        }</span>
<span class="fc" id="L227">        return Optional.empty();</span>
    }

    static BigDecimal getAvailableBalance(final OperationsContext oc,
                                                    final Collection&lt;Investment&gt; investmentsInSession) {
<span class="fc" id="L232">        final boolean isDryRun = oc.isDryRun();</span>
<span class="fc" id="L233">        final int dryRunInitialBalance = oc.getDryRunInitialBalance();</span>
<span class="pc bpc" id="L234" title="1 of 4 branches missed.">        BigDecimal balance = (isDryRun &amp;&amp; dryRunInitialBalance &gt;= 0) ?</span>
<span class="fc" id="L235">                BigDecimal.valueOf(dryRunInitialBalance) :</span>
<span class="fc" id="L236">                oc.getAuthentication().getApi().getWallet().getAvailableBalance();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (isDryRun) {</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            for (final Investment i : investmentsInSession) {</span>
<span class="fc" id="L239">                balance = balance.subtract(BigDecimal.valueOf(i.getAmount()));</span>
<span class="fc" id="L240">            }</span>
        }
<span class="fc" id="L242">        return balance;</span>
    }

    public static Collection&lt;Investment&gt; invest(final OperationsContext oc) {
<span class="fc" id="L246">        final int minimumInvestmentAmount = Operations.MINIMAL_INVESTMENT_ALLOWED;</span>
<span class="fc" id="L247">        final List&lt;Investment&gt; investmentsMade = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L248">        BigDecimal availableBalance = Operations.getAvailableBalance(oc, investmentsMade);</span>
<span class="fc" id="L249">        Operations.LOGGER.info(&quot;RoboZonky starting account balance is {} CZK.&quot;, availableBalance);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        while (availableBalance.compareTo(BigDecimal.valueOf(minimumInvestmentAmount)) &gt;= 0) {</span>
<span class="fc" id="L251">            final Optional&lt;Investment&gt; investment =</span>
<span class="fc" id="L252">                    Operations.identifyLoanToInvest(oc, investmentsMade, availableBalance);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (investment.isPresent()) {</span>
<span class="fc" id="L254">                investmentsMade.add(investment.get());</span>
<span class="fc" id="L255">                availableBalance = Operations.getAvailableBalance(oc, investmentsMade);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">                if (oc.isDryRun()) {</span>
<span class="nc" id="L257">                    Operations.LOGGER.info(&quot;Simulated new account balance is {} CZK.&quot;, availableBalance);</span>
                } else {
<span class="fc" id="L259">                    Operations.LOGGER.info(&quot;New account balance is {} CZK.&quot;, availableBalance);</span>
                }
            } else {
                break;
            }
<span class="fc" id="L264">        }</span>
<span class="fc" id="L265">        return Collections.unmodifiableList(investmentsMade);</span>
    }

    private static Optional&lt;Investment&gt; invest(final OperationsContext oc, final Investment i) {
<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (oc.isDryRun()) {</span>
<span class="fc" id="L270">            Operations.LOGGER.info(&quot;This is a dry run. Not investing {} CZK into loan {}.&quot;, i.getAmount(),</span>
<span class="fc" id="L271">                    i.getLoanId());</span>
<span class="fc" id="L272">            return Optional.of(i);</span>
        } else {
<span class="fc" id="L274">            Operations.LOGGER.info(&quot;Attempting to invest {} CZK into loan {}.&quot;, i.getAmount(), i.getLoanId());</span>
            try {
<span class="fc" id="L276">                oc.getAuthentication().getApi().invest(i);</span>
<span class="fc" id="L277">                Operations.LOGGER.warn(&quot;Investment operation succeeded.&quot;);</span>
<span class="fc" id="L278">                return Optional.of(i);</span>
<span class="fc" id="L279">            } catch (final Exception ex) {</span>
<span class="fc" id="L280">                Operations.LOGGER.warn(&quot;Investment operation failed.&quot;, ex);</span>
<span class="fc" id="L281">                return Optional.empty();</span>
            }
        }
    }

    private static Optional&lt;Investment&gt; invest(final OperationsContext oc, final Loan loan, final int loanAmount) {
<span class="fc" id="L287">        final Investment investment = new Investment(loan, loanAmount);</span>
<span class="fc" id="L288">        return Operations.invest(oc, investment);</span>
    }

    public static Optional&lt;Investment&gt; invest(final OperationsContext oc, final int loanId, final int loanAmount) {
<span class="nc" id="L292">        final Investment investment = new Investment(loanId, loanAmount);</span>
<span class="nc" id="L293">        return Operations.invest(oc, investment);</span>
    }

    public static OperationsContext login(final Authenticator authenticationMethod, final boolean dryRun,
                                          final int dryRunInitialBalance, final InvestmentStrategy strategy)
            throws LoginFailedException {
        try {
            // register Jackson
<span class="nc" id="L301">            final ResteasyProviderFactory instance = ResteasyProviderFactory.getInstance();</span>
<span class="nc" id="L302">            RegisterBuiltin.register(instance);</span>
<span class="nc" id="L303">            instance.registerProvider(ResteasyJackson2Provider.class);</span>
            // authenticate
<span class="nc" id="L305">            final ResteasyClientBuilder clientBuilder = new ResteasyClientBuilder();</span>
<span class="nc" id="L306">            clientBuilder.providerFactory(instance);</span>
<span class="nc" id="L307">            clientBuilder.connectionPoolSize(Operations.CONNECTION_POOL_SIZE);</span>
<span class="nc" id="L308">            final Authentication auth = authenticationMethod.authenticate(Operations.ZONKY_URL, clientBuilder);</span>
<span class="nc" id="L309">            return new OperationsContext(auth, strategy, dryRun, dryRunInitialBalance, Operations.CONNECTION_POOL_SIZE);</span>
<span class="nc" id="L310">        } catch (final RuntimeException ex) {</span>
<span class="nc" id="L311">            throw new LoginFailedException(&quot;Error while instantiating Zonky API proxy.&quot;, ex);</span>
        }
    }

    public static OperationsContext login(final Authenticator authenticationMethod, final boolean dryRun,
                                          final int dryRunInitialBalance) throws LoginFailedException {
<span class="nc" id="L317">        return Operations.login(authenticationMethod, dryRun, dryRunInitialBalance, null);</span>
    }

    public static void logout(final OperationsContext oc) throws LogoutFailedException {
        try {
<span class="nc" id="L322">            oc.getAuthentication().getApi().logout();</span>
<span class="nc" id="L323">        } catch (final RuntimeException ex) {</span>
<span class="nc" id="L324">            throw new LogoutFailedException(&quot;Error while logging out Zonky.&quot;, ex);</span>
<span class="nc" id="L325">        }</span>
<span class="nc" id="L326">        oc.dispose();</span>
<span class="nc" id="L327">        Operations.LOGGER.info(&quot;Logged out of Zonky.&quot;);</span>
<span class="nc" id="L328">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>